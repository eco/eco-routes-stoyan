# Eco-Routes Scripts

This directory contains scripts for deploying, verifying, and publishing the Eco-Routes protocol. The scripts are divided into two main categories:

1. **Deployment Scripts**: Shell scripts and Solidity scripts for deploying and verifying contracts
2. **Semantic Release Scripts**: TypeScript modules for versioning, building, and publishing npm packages

## Directory Structure

- `scripts/` - Root scripts directory
  - `createXOld/` - Legacy deployment scripts using CreateX (archived)
  - `semantic-release/` - Semantic release automation scripts
  - `utils/` - Shared utility scripts
  - `*.sh` - Direct deployment and verification shell scripts
  - `Deploy.s.sol` - Main Foundry deployment script

## Semantic Release System

The Eco-Routes protocol uses a custom semantic-release setup that automates versioning, deterministic contract deployment, verification, and npm package publishing.

### Overview of the Semantic Release Process

Our semantic-release system handles the complete lifecycle:

1. **Version Determination**: Analyzes commit messages to determine the next version number
2. **Solidity Version Updates**: Updates version strings in Solidity contracts
3. **Deterministic Deployment**: Deploys contracts with version-derived salts for consistent addresses
4. **Address Collection**: Generates deployAddresses.json for client use
5. **Package Building**: Creates TypeScript packages with ABIs and address maps
6. **NPM Publishing**: Publishes the package with proper tags (latest, beta, etc.)

### Configuration Files

- `.releaserc.json`: Main semantic-release configuration
  - Defines branch rules and version channels
  - Configures plugins and their order
  - Sets up commit message analysis rules

Example `.releaserc.json`:

```json
{
  "branches": [
    "main",
    {
      "name": "semantic-release",
      "channel": "beta"
    }
  ],
  "repositoryUrl": "git@github.com:eco/eco-routes.git",
  "plugins": [
    ["@semantic-release/commit-analyzer", {...}],
    "@semantic-release/release-notes-generator",
    "@semantic-release/changelog",
    "./dist/semantic-release/index.js",
    ["@semantic-release/git", {...}],
    "@semantic-release/github"
  ]
}
```

### Custom Plugin

We've created a custom semantic-release plugin that handles our contract deployment and package build process. Key files include:

- `semantic-release/index.ts`: Entry point that defines lifecycle methods
- `semantic-release/sr-version.ts`: Updates version strings in Solidity files
- `semantic-release/sr-prepare.ts`: Orchestrates deployment and building
- `semantic-release/sr-deploy-contracts.ts`: Handles multi-chain deployments
- `semantic-release/sr-build-package.ts`: Creates npm packages
- `semantic-release/sr-publish.ts`: Publishes to npm with appropriate tags

### NPM Tagging Strategy

Our system supports distributing packages with different tags:

- **Latest tag**: Normal production releases from the main branch
- **Beta tag**: Pre-releases from the semantic-release branch
- **Custom tags**: Other tags can be defined using the `channel` property

The `channel` property in `.releaserc.json` defines how packages are tagged in npm without affecting the version number.

### CHANGELOG Generation

The CHANGELOG.md file is automatically generated by the "@semantic-release/changelog" plugin. It:

1. Extracts information from commit messages
2. Groups changes by type (features, fixes, etc.)
3. Includes links to commits and PRs
4. Applies formatting based on conventional commit standards

Commit messages must follow the [Conventional Commits](https://www.conventionalcommits.org/) format:

```
<type>(<scope>): <description>

[optional body]

[optional footer(s)]
```

Our system adds special handling for:

- `feat`: Triggers a minor version bump
- `fix`: Triggers a patch version bump
- `chain`: Triggers a patch version bump (custom to our needs)
- `breaking`: Triggers a major version bump
- `BREAKING CHANGE`: Footer that triggers a major version bump

### Testing Locally

You can test the release process locally using the `eco-routes-local.ts` script:

```bash
# Set required environment variables in .env
npm run semantic:pub
# or
yarn semantic:pub
```

This script runs all steps of the semantic-release process with test values. To customize the test:

1. Edit `semantic-release/eco-routes-local.ts` to change test parameters:

   ```typescript
   const context: SemanticContext = {
     nextRelease: {
       version: "2.0.1", // Version to use for testing
       gitTag: "v2.0.1", // Git tag format
       notes: "Test release", // Release notes
       type: "patch", // Release type
       channel: "beta", // NPM tag to use
     },
     // ...
   }
   ```

2. Run with environment variables to control behavior:

   ```bash
   # To simulate but not publish
   NOT_DRY_RUN=false yarn semantic:pub

   # To actually publish (be careful!)
   NOT_DRY_RUN=true yarn semantic:pub
   ```

### Triggering Releases

Releases can be triggered through multiple methods:

1. **Direct GitHub Actions**: Manually trigger the `release.yaml` workflow
2. **Specific Commits**: Add a commit with a specific format to trigger a release:

   ```
   fix: trigger patch release
   feat: trigger minor release
   feat!: trigger major release
   ```

3. **From eco-chains Repository**: When the eco-chains repository is updated, it
   can trigger our release process through the `trigger-from-chains.yaml` workflow

   - This is configured to respond to the `eco-chains-tag-pushed` repository_dispatch event
   - It creates an empty commit with the appropriate conventional commit message

4. **Manual Release Trigger**: Use the workflow_dispatch event with a release_type selection:
   - patch: Increments the patch version (1.0.0 → 1.0.1)
   - minor: Increments the minor version (1.0.0 → 1.1.0)
   - major: Increments the major version (1.0.0 → 2.0.0)
   - prepatch/preminor/premajor: Creates pre-release versions

### Required Environment Variables

For semantic-release to work, these environment variables are required:

```bash
# For deployment
PRIVATE_KEY=<Your private key>
ALCHEMY_API_KEY=<Your Alchemy API key if using Alchemy RPCs>
CHAIN_DATA_URL=<URL or path to chain configuration>
RESULTS_FILE=<Path for deployment results>

# For publishing
NPM_TOKEN=<NPM token with publish access>

# For verification
VERIFICATION_KEYS=<JSON string of API keys>
# or
VERIFICATION_KEYS_FILE=<Path to verification keys file>
```

In GitHub Actions, these are stored as secrets and passed to the workflow.

## Deployment Scripts

The deployment scripts handle the deterministic deployment of contracts across multiple chains. These scripts can be used directly or through the semantic-release process.

## Setup Requirements

### Environment Variables

Create a `.env` file in the project root with the following variables:

```bash
# Required for all deployments
PRIVATE_KEY=<Your private key>
CHAIN_DATA_URL=<URL or local path to the chain data JSON file>
SALT=<Deployment salt as a bytes32 value>

# For MultiDeploy.sh
RESULTS_FILE=<Path to store deployment results>
APPEND_RESULTS=<true/false> # Optional: Set to true to append to existing results file

# For SingletonFactory deployment
ALCHEMY_API_KEY=<Your Alchemy API key if using Alchemy RPCs>

# For Deploy.s.sol
MAILBOX=<Optional: Mailbox contract address for HyperProver>
ROUTER=<Optional: Router contract address for MetaProver>

# For VerifyResults.sh
VERIFICATION_KEYS_FILE=<Path to verification keys JSON file>
VERIFICATION_KEYS=<Optional: JSON string of verification keys>
```

### Account Funding

The deployer account must have:

1. **For SingletonFactory deployment**: If the SingletonFactory needs deployment, the account needs exactly 0.0247 ETH on the target chain. The script will automatically fund the account if needed.

2. **For other contract deployments**: Sufficient funds to cover gas costs for all contract deployments.

## Script Usage

### 1. Deploy SingletonFactory (ERC-2470)

This script deploys the standard ERC-2470 Singleton Factory if not already deployed:

```bash
./scripts/deploySingletonFactory.sh
```

The script:

- Checks if the factory exists at the standard address on each chain
- Funds the dedicated factory deployer address if needed
- Deploys the factory using a pre-signed transaction

**Always run this script first** before other deployments to ensure the Singleton Factory is available.

### 2. MultiDeploy

This script deploys contracts across multiple chains:

```bash
./scripts/MultiDeploy.sh
```

The script:

- Loads chain data from the specified URL or local file
- Deploys contracts on each chain using the `Deploy.s.sol` script
- Saves deployment data to the specified results file

### 3. Deploy.s.sol

This Foundry script handles the actual contract deployments using CREATE2/CREATE3:

- **IntentSource**: Deployed using CREATE2
- **Inbox**: Deployed using CREATE2
- **HyperProver**: Deployed using CREATE3 (if MAILBOX is provided)
- **MetaProver**: Deployed using CREATE3 (if ROUTER is provided)

The script logs all deployed contract addresses and generates verification data.

### 4. VerifyResults.sh

This script verifies all contracts deployed by MultiDeploy.sh on their respective block explorers:

```bash
./scripts/VerifyResults.sh
```

The script:

- Reads deployment data from RESULTS_FILE
- Uses verification API keys from VERIFICATION_KEYS_FILE
- Verifies each contract on the appropriate block explorer
- Supports constructor arguments stored in the deployment data
- Automatically retries failed verifications

## Deployment Process

Follow these steps for a complete deployment:

1. Configure your `.env` file with all required environment variables
2. Create a verification keys file (see `verification-keys-example.json`)
3. Run `./scripts/deploySingletonFactory.sh` to ensure the Singleton Factory is deployed
4. Run `./scripts/MultiDeploy.sh` to deploy all contracts across chains
5. Run `./scripts/VerifyResults.sh` to verify the deployed contracts

## Chain Data JSON Format

The CHAIN_DATA_URL can point to either:

- A remote HTTP URL: `https://raw.githubusercontent.com/eco/eco-chains/refs/heads/main/src/assets/chain.json`
- A local file path: `/path/to/local/chains.json`

The JSON file should have the following structure:

```json
{
  "1": {
    "url": "https://eth-mainnet.alchemyapi.io/v2/${ALCHEMY_API_KEY}",
    "mailbox": "0x123...",
    "gasMultiplier": "1.2"
  },
  "10": {
    "url": "https://opt-mainnet.g.alchemy.com/v2/${ALCHEMY_API_KEY}",
    "mailbox": "0x456..."
  }
}
```

Each entry contains:

- Chain ID as the key
- `url`: RPC endpoint (with optional environment variable substitution)
- `mailbox`: Address of the Mailbox contract on this chain (if applicable)
- `gasMultiplier`: Optional gas multiplier for this chain

## Notes

- All deployments use deterministic addresses through CREATE2/CREATE3
- The same SALT value ensures consistent addresses across all environments
- Contract addresses are predictable and can be computed before deployment
- All scripts are idempotent - running them multiple times will not redeploy existing contracts

## Verification Keys Format

The VERIFICATION_KEYS_FILE should contain a JSON object with chain IDs as keys and API keys as values:

```json
{
  "1": "YOUR_ETHERSCAN_API_KEY",
  "10": "YOUR_OPTIMISM_API_KEY",
  "56": "YOUR_BSCSCAN_API_KEY",
  "137": "YOUR_POLYGONSCAN_API_KEY",
  "43114": "YOUR_AVALANCHE_API_KEY",
  "42161": "YOUR_ARBISCAN_API_KEY"
}
```

Each chain requires its own specific API key for the relevant block explorer:

- Chain ID 1: Etherscan API key
- Chain ID 10: Optimism Explorer API key
- Chain ID 56: BscScan API key
- And so on for other chains

You can also provide the verification keys as a JSON string in the VERIFICATION_KEYS environment variable instead of using a file.
